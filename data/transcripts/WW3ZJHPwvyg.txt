 The following content is provided under a Creative Commons license. Your support will help MIT OpenCourseWare continue to offer high quality educational resources for free. To make a donation or to view additional materials from hundreds of MIT courses, visit MIT OpenCourseWare at ocw.mit.edu. MIT CTL & SCALE 1 A bunch of x's and a bunch of y's. The y's were univariate, just one real value random variable. And the x's were vectors that described a bunch of attributes for each of our individuals or each of our observations. Let's assume now that we're given essentially only the x's. This is sometimes referred to as unsupervised learning. There's just the x's. Usually supervision is done by the y's. And so what you're trying to do is to make sense of this data. You're going to try to understand this data, represent this data, visualize this data, try to understand something. So if I give you a d-dimensional random vectors, and you're going to have n independent copies of this random vector. So you will see that I'm going to very quickly run into some limitations about what I can actually draw on the board, because I'm using boldface here. I'm also going to use the blackboard boldface. So it's going to be a bit difficult. So tell me if you're actually a little confused by what is a vector, what is a number, and what is a matrix. But we'll get there. So I have x in our d, and that's a random vector. And I have x1 to xn that are iid. They're independent copies of x. So you can think of those as being the realization of these guys are going to be a cloud of endpoints in r to the d. And we're going to think of d as being fairly large. And for this to start to make sense, we're going to think of d as being at least 4, meaning that you're going to have a hard time visualizing those things. If it was 3 or 2, you would be able to draw these points. And that's pretty much as much sense you're going to be making about those guys, just looking at the cloud of point. So I'm going to write each of those x's, so this vector x, as d-coordinate. And I'm going to write them as x1 to xd. And I'm going to stack them into a matrix. So once I have those guys, I'm going to have a matrix. Here I'm going to use the double bar. And it's x1 transpose xn transpose. So what it means is that the coordinates of this guy, of course, are x1, 1. Here I have I'm of size d, so I have x1d. And here I have xn1, xnd. And so the i-th, j-th, i-th row and j-th column is the matrix xij, is the entry xi to the, sorry. So the rows here are the observations, and the columns are the covariates or attributes. So this is an n by d matrix. This is really just some bookkeeping. How do we store this data somehow? And the fact that we use a matrix just for regression is going to be convenient, because we're going to be able to talk about projections, going to be able to talk about things like this. So everything I'm going to say now is about variances or covariances of those things, which means that I need two moments. If the variance does not exist, there's nothing I can say about this problem. So I'm going to assume that the variance exists. And one way to just put it is to say that the two norm of those guys is finite, which is another way to say that each of them is finite. I mean, you can think of it the way you want. All right, so now the mean of x, so I have a random vector. So I can talk about the expectation of x. That's a vector that's in Rd. And that's just taking the expectation entry-wise. Sorry. x1, 1, sorry, x1, xd. OK, so I should say it out loud. For the purpose of this class, I will denote by subscripts the indices that corresponds to observations and superscripts the indices that correspond to coordinates of a variable. And I think that's the same convention that we took for the regression case. Of course, you could use whatever you want. If you want to put commas, et cetera, it becomes just a bit more complicated. All right, and so now once I have this, so this tells me where my cloud of point is centered, right? So if I have a bunch of points, OK, so now I have a distribution on Rd. So maybe I should talk about this. I'll talk about this when we talk about the empirical version. But if you think that you have, say, a two-dimensional Gaussian random variable, then you have a center in two dimension, which is where it peaks, basically. And that's what we're talking about here. But the other thing we want to know is how much does it spread in every direction, right? So in every direction of the two-dimensional thing, I can try to understand how much spread I'm getting. And the way you measure this is by using covariance, right? So the covariance matrix, sigma, that's a matrix which is d by d. And it records in the jk-th entry, it records the covariance between the j-th coordinate of x and the k-th coordinate of x, OK? So with entries, OK, so I have sigma. Sigma, which is sigma 1, 1, sigma d, d, sigma 1, d, sigma d, 1. OK, and here I have sigma jk. And sigma jk is just the covariance between xj, the j-th coordinate, and the k-th coordinate. OK? So in particular, it's symmetric because the covariance between xj and xk is the same as the covariance between xk and xj. I should not put those parentheses here. I do not use them in this. OK? Just the covariance matrix. So that's just something that records everything. And so what's nice about the covariance matrix is that if I actually give you x as a vector, you actually can build the matrix just by looking at vectors times vectors transposed, rather than actually thinking about building it coordinate by coordinate. So for example, if you're used to using MATLAB, that's the way you want to build a covariance matrix, because MATLAB is good at manipulating vectors and matrices, rather than just entry by entry. OK, so what is the covariance between xj and xk? Well, by definition, it's the expectation of xj and xk minus the expectation of xj times the expectation of xk. That's the definition of the covariance. I hope everybody's seen that. And so in particular, I can actually see that this thing can be written as, sigma can now be written as the expectation of x, x transpose minus the expectation of x times the expectation of x transpose. Why? Well, let's look at the jk-th coefficient of this guy. So here, if I look at the jk-th coefficient, I see what? Well, I see that it's the expectation of x, x transpose jk, which is equal to the expectation of x, x transpose jk. And what are the entries of x, x transpose? Well, they're of the form xj times xk, exactly. So this is actually equal to the expectation of xj times xk. And this is actually not the way I want to write it. I want to write it. OK? Is that clear? That when I have a rank 1 matrix of this form, x, x transpose, the entries are of this form, right? Because if I take, for example, think about x, y, z, and then I multiply by x, y, z, what I'm getting here is x. Maybe I should actually use indices here. x1, x2, x3, x1, x2, x3. The entries are x1, x1, x1, x2, x1, x3, x2, x1, x2, x2, x2, x3, x3, x1, x3, x2, x3, x3. OK? So indeed, this is exactly of the form. If you look at jk, you get exactly xj times xk. OK? That's the beauty of those matrices. So now once I have this, I can do exactly the same thing, except that here, if I take the jk-th entry, I will get exactly the same thing, except that it's not going to be the expectation of the product, but the product of the expectation, right? So I get that the jk-th entry of E of x, E of x transpose is just the j-th entry of E of x times the k-th entry of E of x. So if I put those two together, it's actually telling me that if I look at the jk-th entry of sigma, which I called little sigma jk, then this is actually equal to what? It's equal to the first term minus the second term. The first term is exponential of expectation of xj, xk, minus expectation of xj, expectation of xk, which, oh, by the way, I forgot to say this is actually equal to the expectation of xj times the expectation of xk, because that's just the definition of the expectation of random vectors. So my j and my k are now inside. And that's by definition the covariance between xj and xk. So just if you've seen those manipulations between vectors, hopefully you're bored out of your mind. And if you have not, then that's something you just need to get comfortable with. So one thing that's going to be useful is to know very quickly what's called the outer product of a vector with itself, which is the vector times the vector transpose, what the entries of these things are. And that's what we've been using on this second set of boards. So everybody agrees now that we've showed that the covariance matrix can be written in this vector form. So expectation of x, x transpose minus expectation of x, expectation of x transpose. Just like the covariance can be written in two ways, we know that the covariance can also be written as the expectation of xj minus expectation of xj times xk minus expectation of xk. OK? Right? That's the, sometimes this is the original definition of covariance. This is the second definition of covariance, just like you have the variance, which is the expectation of the square of x minus c of x, or the expectation of x squared minus the expectation of x squared. It's the same thing for covariance. And you can actually say this in terms of vectors, right? So this actually implies that you can also rewrite sigma as the expectation of x minus expectation of x times the same thing transpose. Right? And the reason is because if you just distribute those guys, this is just the expectation of, well, xx transpose minus x expectation of x transpose minus expectation of xx transpose. And then I have plus expectation of x expectation of x transpose. Now, things could go wrong, because the main difference between matrices slash vectors and numbers is that multiplication does not commute, right? So in particular, those two things are not the same thing. And so that's the main difference that we have before, but it actually does not matter for a problem, is because what's happening is that when I take the expectation of this guy, then it's actually the same as the expectation of this guy. And so just because the expectation is linear, so what we have is that sigma now becomes equal to the expectation of xx transpose minus the expectation of x expectation of x transpose minus expectation of x expectation of x transpose. And then I have, well, really what I have is this guy. And then I have plus expectation of x expectation of x transpose. And now, those three things are actually equal to each other, just because the expectation of x transpose is the same as the expectation of x transpose. And so what I'm left with is just the expectation of xx transpose minus the expectation of x expectation of x transpose. OK? So same thing that's happening when you want to prove that you can write the covariance either this way or that way. The same thing happens for matrices, for vectors, or covariance matrix to go together. Is there any questions so far? And if you have some, please tell me, because I don't know to which extent you guys are comfortable with this at all or not. OK? So let's move on. All right, so of course, this is what I'm describing in terms of the distribution. Right here, I took expectations. Covariances are also expectations. So those depend on some distribution of x, right? If I wanted to compute that, I would basically need to know what the distribution of x is. Now, we're doing statistics, so I need to basically, my question is going to be to say, well, how well can I estimate the covariance matrix itself or some properties of this covariance matrix based on data? So if I want to understand what my covariance matrix looks like based on data, I'm going to have to basically form its empirical counterparts, which I can do by doing the age-old statistical trick, which is replace your expectation by an average. So everything that's on the board, you see expectation, just replace it by an average. So now I'm going to be given x1, xn. So I'm going to define the empirical mean. So really, the idea is take your expectation and replace it by 1 over n sum, right? And so the empirical mean is just 1 over n sum of the xi's. I'm guessing everybody knows how to average vectors. It's just the average of the coordinates. So I will write this as x bar. And the empirical covariance matrix, often called sample covariance matrix, hence the notation S. Well, this is my covariance matrix, right? Let's just replace the expectations by averages. 1 over n sum from i equal 1 to n of xi, xi transpose, minus this is an expectation of x. I will replace it by the average, which I just called x bar, x bar transpose. And that's when I want to use the notation, the second definition. But I could actually do exactly the same thing. Using this definition here, so this is actually 1 over n sum from i equal 1 to n of xi minus x bar, xi minus x bar transpose. And those are actually, I mean, in a way it looks like I could define two different estimators. But you can actually check. And I do encourage you to do this if you're not comfortable making those manipulations. You can actually check that those two things are actually exactly the same. So now I'm going to want to talk about matrices. Remember, we defined this big matrix, x with the double bar. And the question is, can I express both x bar and the sample covariance matrix in terms of this big matrix, x? Because right now, it's still expressed in terms of the vectors. I'm summing those vectors, vectors transpose. The question is, can I just do that in a very compact way, in a way that I can actually remove this sum term? That's going to be the goal. I mean, that's not a notational goal. That's really something that we want. That's going to be convenient for us, just like it was convenient to talk about matrices when we did linear regression. OK, x bar. We just said it's 1 over n sum from i equal 1 to n of xi. Now remember, what does this matrix look like? We said that x bar, x is this guy. So if I look at x transpose, the columns of this guy becomes x1, my first observation, x2, my second observation, all the way to xn, my last observation. Agreed? That's what x transpose is. So if I want to sum those guys, I can multiply by the old ones vector. So that's what the definition of the old ones vector is. Well, it's just a bunch of 1's. And r, n in this case. And so when I do x transpose 1, what I get is just the sum from i equal 1 to n of the xi's. So if I divide by n, I get my average. So here, I definitely removed the sum term. Let's see if with the covariance matrix we can do the same. Well, that's actually a little more difficult to see, I guess. But let's use this definition for S. And one thing that's actually going to be, so let's see for one second what, so it's going to be something that involves x multiplying x with itself. And the question is, is it going to be multiplying x with x transpose or x transpose with x? To answer this question, you can go the easy route, which says, well, my covariance matrix is of size what? What is the size of S? d by d. x is of size n by d. So if I do x times x transpose, I'm going to have something which is of size n by n. If I do x transpose x, I'm going to have something which is d by d. That's the easy route. There's basically one of the two guys. You can actually open the box a little bit and see what's going on in there. If you do x transpose x, which we know gives you a d by d, you see that x is going to have vectors that are of the form xi. And x transpose is going to have vectors that are of the form xi transpose. And so this is actually probably the right way to go. So let's look at what x transpose x is giving us. So I claim that it's actually going to give us what we want. But rather than actually going there, I mean, we could check it entry by entry. But there's actually a nice thing we can do. Before we go there, let's write x transpose as the following sum of variables, x1, and then just a bunch of 0's everywhere else. So it's still d by n. So n minus 1 of the columns are equal to 0 here. Then I'm going to put a 0 and then put x2, and then just a bunch of 0's. So that's just 0, 0 plus 0, 0 all the way to xn. OK, everybody agrees with it? See what I'm doing here? I'm just splitting it into a sum of matrices that only have one non-zero columns. Clearly, that's true. Now let's look at the product of this guy with itself. So let's call these matrices M1, M2, Mn. So when I do x transpose x, what I do is the sum of the Mi's for i equal 1 to n times the sum of the Mi transpose. Now, the sum of the Mi's transpose is just the sum of each of the Mi's transpose. So now I just have this product of two sums, so I'm just going to re-index the second one by j. So this is sum for i equal 1 to n, j equal 1 to n of Mi Mj transpose. And now what we want to notice is that if i is different from j, what's happening? Well, if i is different from j, let's look at, say, M1 times x M2 transpose. So what is the product between those two matrices? AUDIENCE 2. I don't know. I don't know the next two yet. PHILIPPE RIGOLLET. There's an entry? AUDIENCE 2. Well, it's an entry. It's like a dot product. Maybe the next one. PHILIPPE RIGOLLET. A dot product is just going to be one number, right? So this is going to be a matrix. It's a product of two matrices, right? This is a matrix times a matrix. So this should be a matrix of size d by d. Yeah, I should see a lot of hands that look like this, right? Because look at this, right? So let's multiply the first. Let's look at what's going on in the first column here. I'm multiplying this column with each of those rows. The only non-zero coefficient is here, and it only hits this column of zeros. So every time, this is going to give me 0, 0, 0, 0. And it's going to be the same for every single one of them. So this matrix is just full of zeros, right? They never hit each other when I do the matrix-matrix multiplication. Every non-zero hits a zero. So what it means is, and this, of course, you can check for every i different from j. So this means that mi times mj transpose is actually equal to 0 when i is different from j, right? Everybody is OK with this? So what that means is that when I do this double sum, really, it's a simple sum. There's only just the sum from i equal 1 to n of mi mi transpose. Because this is the only terms in this double sum that are not going to be 0 when I hit m1 with m1 itself. Now, let's see what's going on when I do m1 times m1 transpose. Well, now, if I do mi times mi transpose, now this guy becomes x1. It's here. And so now I really have x1 times x1 transpose. So this is really just the sum from i equal 1 to n of xi xi transpose. Yeah? OK? Just because mi mi transpose is xi xi transpose. There's nothing else there. So that's the good news, right? This term here is really just x transpose x divided by n. Yeah? OK, I can use that guy again, I guess. Well, no. Let's just. OK, so let me rewrite S. That's the definition we have. And we know that this guy already is equal to 1 over n x transpose x. X bar x bar transpose, we know that x bar, we just proved that x bar, sorry, little x bar was equal to 1 over n x bar transpose times the all ones vector. So I'm just going to do that. So that's just going to be minus. I'm going to pull my two 1 over n's. One from this guy, one from this guy. So I'm going to get 1 over n squared. And then I'm going to get x bar. Sorry, there's no x bar here. It's just x. x transpose all ones times x transpose all ones transpose. Right? And x transpose all ones transpose. The rule, if I have a times b transpose, it's b transpose times a transpose. Right? That's just the rule of transposition. So this is 1 transpose x transpose. And so when I put all these guys together, this is actually equal to 1 over n x transpose x minus 1 over n squared x transpose 1 1 transpose x. Because x transpose transpose is x. OK? So now I have something which is of the form x transpose x to the left x transpose to the right x. Here I have x transpose to the left x to the right. So I can factor out whatever is in there. So I can write s as 1 over n, sorry, x transpose times 1 over n times the identity of our d. And then I have minus 1 over n 1 1 transpose x. OK, because if you, I mean, you can distribute it back. Right? So here I'm going to get what? x transpose identity times x, the whole thing divided by n, that's this term. And then the second one is going to be 1 over n squared. And then I'm going to get 1 over n squared times x transpose 1 1 transpose, which is this guy, times x. And that's the right thing. OK? So the way it's written, I factored out one of the 1 over n. So I'm just going to do the same thing as on the slide. So I'm just factoring out this 1 over n here. So it's 1 over n times x transpose identity of our d divided by n minus, sorry, divided by 1 this time, minus 1 over n 1 1 transpose times x. OK? So that's just what's on the slide. What does the matrix 1 1 transpose look like? It's just all 1's, right? Because the entries are the products of the coordinates of the 1 vectors with the coordinates of the 1 vectors. So I only get 1. So it's a d by d matrix with only 1's. So this matrix I can actually write exactly, right? H, this matrix that I called H, which is what's sandwiched in between this x transpose and x. By definition, I said this is the definition of H. Then this thing, I can write its coordinates exactly. We know it's identity divided by n minus, sorry, I don't know why I keep on dividing by n, minus 1 over n 1 1 transpose. So it's this matrix with only 1's on the diagonals and 0's elsewhere minus a matrix that only has 1 over n everywhere. So the whole thing is 1 minus 1 over n on the diagonals, and then minus 1 over n here. And now I claim that this matrix is an orthogonal projector. Now, I'm writing this, but it's completely useless. This is just a way for you to see that it's actually very convenient now to think about this problem as being a matrix problem, because things are much nicer when you think about the actual form of your matrices. They could tell you, here is the matrix. I mean, imagine you're sitting at a midterm. And I say, here's the matrix that has 1 minus 1 over n on the diagonals and minus 1 over n on the off diagonal. Prove to me that it's a projector matrix. You're going to have to basically take this guy times itself. It's going to be really complicated. So we know it's symmetric. That's for sure. But the fact that it has this particular way of writing it is going to make my life super easy to check this. That's the definition of a projector. It has to be symmetric, and it has to square to itself, because we just said in the chapter on linear regression that once you project, if you apply the projection again, you're not moving, because you're already there. So why is h squared equal to h? Well, let's just write h squared. It's the identity minus 1 over n 1, 1 transpose times the identity minus 1 over n 1, 1 transpose. Let's just expand this now. This is equal to the identity minus, well, the identity times 1, 1 transpose is just the identity. So it's 1, 1 transpose. So 1 over n 1, 1 transpose minus 1 over n 1, 1 transpose. And then that's going to be what makes the deal, is that I get this 1 over n squared this time. And then I get the product of 1 over n transpose. Let's write it completely. I get 1, 1 transpose times 1, 1 transpose. OK? But this thing here, what is this? n, right? It's the inner product of the L1's vector with the L1's vector. So I'm just summing n times 1 squared, which is n. So this is equal to n. So I pull it out, cancel one of the n's, and I'm back to what I had before. So I had identity minus 2 over n 1, 1 transpose plus 1 over n 1, 1 transpose, which is equal to h, because one of the 1 over n's cancel. OK? So it's a projection matrix. It's projecting onto some linear space, right? It's taking a matrix. Sorry, it's taking a vector. It's projecting onto a certain space of vectors. What is this space? So I'm only asking this question. The answer to this question is words, right? So how would you describe the vectors onto which this matrix is projecting? Well, if you want to answer this question, the way you would tackle it is first by saying, OK, what does a vector, which is of the form h times something, look like? What can I say about this vector that's going to be definitely giving me something about the space on which it projects? I need to know a little more to know that it projects exactly onto this. But one way we can do this is just see how it acts on a vector. What does it do to a vector to apply h, right? So I take v. And let's see what taking v and applying h to it looks like. Well, it's the identity minus something. So it takes v, and it removes something from v. What does it remove? Well, it's 1 over n times v transpose 1 times the all 1's vector, right? Agreed? I just wrote v transpose 1 instead of 1 transpose v, which are the same thing. What is this thing? What should I call it in mathematical notation? v bar, right? I should call it v bar, because this is exactly the average of the entries of v. Agreed? This is summing the entries of v's, and this is dividing by the number of those v's. Sorry, now v is in R. Sorry, why do I divide by? I'm just, OK, I need to check what my dimensions are now. No, it's in Rd, right? So why do I divide by n? So it's not really v bar. It's the sum of the v's divided by, right, so it's v bar. Oh, yeah. OK, thank you. So everywhere I wrote hd, that was actually hn. Oh, man, I wish I had a computer now. All right, so yeah, because the, yeah, right? So why it's not, well, why I thought it was d is because I was thinking about the outer dimension of x transpose, which is really the inner dimension that mattered to me, right? So the thing that I can sandwich between x transpose and x has to be n by n. So this was actually n by n. And so that's actually n by n. Everything is n by n. Sorry about that. So this is n. This is n. This is, well, I didn't really tell you what the all ones vector was, but it's also in Rn. Yeah, OK. Thank you. And n. Actually, I used the fact that this was of size n here already. OK, and so that's indeed v bar. So what is this projection doing to a vector? It's removing its average on each coordinate, right? And the effect of this is that v is a vector. What is the average of hv? Right, so it's 0. It's the average of v, which is v bar, minus the average of something that only has v bar as entry, which is v bar. So this thing is actually 0. So let me repeat my question. What subspace does h project? What does h project onto the subspace of vectors that have mean 0? A vector that has mean 0 is a vector. So if you want to talk more linear algebra, v bar, for a vector to have mean 0, it means that v is orthogonal to the span of the all ones vector. That's it. It projects onto the space. So in words, it projects onto the space of vectors that have 0 mean. In linear algebra, it says it projects onto the hyperplane, which is orthogonal to the all ones vector. So that's all. Can you guys still see the screen? Are you good over there? All right, so now what it means is that, well, I'm doing this weird thing. I'm taking the inner product. So S is taking x. And then it's removing its mean of each of the columns of x. When I take h times x, I'm basically applying this projection, which consists in removing the mean of all the x's. And then I multiply by h transpose. But what's actually nice is that, remember, h is a projector, which means that when I look at x transpose hx, it's the same as looking at x transpose h squared x. But since h is equal to h transpose, this is actually the same as looking at x transpose h transpose hx, which is the same as looking at hx transpose hx. So what it's doing, it's first applying this projection matrix h, which removes the mean of each of your columns and then looks at the inner products between those guys. Each entry of this guy is just the covariance between those centered things. That's all it's doing. All right, so those are actually going to be the key statements. So everything we've done so far is really mainly linear algebra. I mean, looking at expectations and covariances, we just use the fact that the expectation was linear. We didn't do much. But now there's a nice thing that's happening. And that's why we're going to switch from the language of linear algebra to more statistical. Because what's happening is that if I look at this quadratic form, so I take sigma. So I take a vector u, and I'm going to look at u. So let's say in Rd. And I'm going to look at u transpose sigma u. What is this doing? Well, we know that u transpose sigma u is equal to what? Well, sigma is the expectation of x, x transpose, minus the expectation of x, expectation of x transpose. Right? So I just substitute in there. Now, u is deterministic. So in particular, I can push it inside the expectation here. Agreed? And I can do the same from the right. So here, when I push u transpose here and u here, what I'm left with is the expectation of u transpose x times x transpose u. OK? And now I can do the same thing for this guy. And this tells me that this is the expectation of u transpose x times the expectation of x transpose u. Of course, u transpose x is equal to x transpose u. And u, yeah. So what it means is that this is actually equal to the expectation of u transpose x squared minus the expectation of u transpose x, the whole thing squared. But this is something that should look familiar. This is really just the variance of this particular random variable, which is of the form u transpose x. u transpose x is a number. It involves a random vector. So it's a random variable. And so it has a variance. And this variance is exactly given by this formula. So this is just the variance of u transpose x. So what we've proved is that if I look at this guy, this is really just the variance of u transpose x. OK? Now, I can do the same thing for the sample variance. Let's do this. And as you can see, spoiler alert, this is going to be the sample variance. OK? So remember, S is 1 over n sum of xi xi transpose minus x bar x bar transpose. So when I do u transpose Su, what it gives me is 1 over n sum from i equal 1 to n of u transpose xi times xi transpose u. So those are two numbers that multiply each other and that happen to be equal to each other. Minus u transpose x bar x bar transpose u, which is also the product of two numbers that happen to be equal to each other. So I can rewrite this with squares. So we're almost there. All I need to know to check is that this thing is actually the average of those guys, right? So u transpose x bar, what is it? It's 1 over n sum from i equal 1 to n of u transpose xi. So it's really something that I can write as u transpose x bar. That's the average of those random variables of the form u transpose xi. So what it means is that u transpose Su, I can write as 1 over n sum from i equal 1 to n of u transpose xi squared minus u transpose x bar squared, which is the empirical variance that we denoted by small s squared, right? So that's the empirical variance of u transpose x1 all the way to u transpose xn. And here, same thing. I use exactly the same thing. I just use the fact that here, the only thing I use is really the linearity of this guy, of 1 over n sum or the linearity of expectation, that I can push things in there. OK? AUDIENCE 2 What do you put in at the end? That sum or the S? PHILIPPE RIGOLLETTIS This one? Yeah, I said it's equal to small s. And I want to make a difference between the big S that I'm using here. So this is equal to small, I don't know, I'm trying to make it look like a calligraphic S squared. OK? So this is nice, right? This covariance matrix, so let's look at capital sigma itself right now. This covariance matrix, we know that if we read its entries, what we get is the covariance between the coordinates of the X's, of the random vector X. And the coordinates, well, by definition, are attached to a coordinate system. So I only know what the covariance of those two things are, or the covariance of those two things are. But what if I want to find coordinates between linear combination of the X's? Sorry, if I want to find covariances between linear combination of those X's? And that's exactly what this allows me to do. It says, well, if I pre and post multiply by u, this is actually telling me what the variance of X along direction u is. OK? So there's a lot of information in there, and it's just really exploiting the fact that there's some linearity going on in the covariance. So why variance? Why is variance interesting for us? I started by saying, here, we're going to be interested in having something to do dimension reduction. Think of your points as being dimension larger than 4, and we're going to try to reduce the dimension. So let's just think for one second, what do we want about a dimension reduction procedure? If I have all my points that live in, say, three dimensions, and I have one point here, and one point here, and one point here, and one point here, and one point here, and I decide to project them onto some plane, but I take a plane that's just like this, what's going to happen is that those points are all going to project to the same point. I'm just going to not see anything. However, if I take a plane which is like this, they're all going to project into some nice line. Maybe I can even project them onto a line, and they will still be far apart from each other. So that's what you want. You want to be able to say, when I take my points, and I say I project them onto lower dimensions, I do not want them to collapse into one single point. I want them to be spread as possible in the direction on which I project. And this is what we're going to try to do. And of course, measuring spread between points can be done in many ways. I mean, you could look at, I don't know, the sum of pairwise distances between those guys. You could look at some sort of energy. You can look at many ways to measure spread in a direction. But variance is a good way to measure spread between points. If you have a lot of variance between your points, then chances are they're going to be spread. Now, this is not always the case. If I have a direction in which all my points are clumped onto one big point and one other big point, it's going to choose this, because that's a direction that has a lot of variance. But hopefully, the variance is going to spread things out nicely. So the idea of principal component analysis is going to try to identify those variances, those directions, along which we have a lot of variance. Reciprocally, we're going to try to eliminate the directions along which we do not have a lot of variance. And let's see why. Well, so here's the first claim. If u transpose Su is equal to 0, what's happening? Well, I know that an empirical variance is equal to 0. What does it mean for an empirical variance to be equal to 0? So I give you a bunch of points. So those points are those points. u transpose x1, u transpose, those are a bunch of numbers. What does it mean to have the empirical variance of those points being equal to 0? They're all the same. So what it means is that when I have my points, so can you find the direction for those points in which they project to all the same point? No, right? There's no such thing. For this to happen, you have to have your points, which are perfectly aligned. And then when you're going to project onto the orthogonal of this guy, they're going to all project to the same point here, which means that the empirical variance is going to be 0. Now, this is an extreme case. This will never happen in practice. Because if that happens, well, I mean, you can basically figure that out very quickly. So in the same way, it's very unlikely that you're going to have u transpose sigma u, which is equal to 0, which means that essentially all your points are most surely, or let's say all of them are orthogonal to u. It's exactly the same thing. It just says that in the population case, there's no probability that your points deviate from this guy here. This happens with no zero probability. And that's just because if you look at the variance of this guy, it's going to be 0. And then that means that there's no deviation. By the way, I'm using the name projection when I talk about u transpose x. So let's just be clear about this. If u, so let's say I have a bunch of points. And u is a vector in this direction. And let's say that u has, so this is 0. This is u. And let's say that u is norm 1. When I look, what is the coordinate of the projection? So what is the length of this guy here? Let's call this guy x1. What is the length of this guy in terms of inner products? This is exactly u transpose x1. This length here, if this is x2, this is exactly u transpose x2. So those u transpose x measure exactly the distance to the origin of those. Think of it as being just an x-axis thing. You just have a bunch of points. You have an origin. And it's really just telling you what the coordinate on this axis is going to be. So in particular, if the empirical variance is 0, it means that all these points project to the same point, which means that they have to be orthogonal to this guy. And you can think of it as being also maybe an entire plane that's orthogonal to this line. So that's why I talk about projection, because the inner products u transpose x is really measuring the coordinate of x when u becomes the y-axis, the x-axis. Now, if u does not have norm 1, then you just have a change of scale here. You just have a change of unit. So this is really u times x1. The coordinate should really be divided by the norm of u. So now, just in the same way, so we're never going to have exactly 0. But if we go to the other end, if u transpose su is large, what does it mean? Well, it means that when I look at my points, as projected onto the axis generated by u, they're going to have a lot of variance. They're going to be far away from each other in average. That's what large variance means, or at least large empirical variance means. And same thing for u. So what we're going to try to find is a u that maximizes this. If I can find a u that maximizes this, so I can look in every direction, and suddenly I find a direction in which the spread is massive, then that's a point on which I'm basically less likely to have my points project onto each other and collide. At least I know they're going to project at least onto two points. So the idea now is to say, OK, let's try to maximize this spread. So we're going to try to find the maximum overall use of u transpose Su. And that's going to be the direction that maximizes the empirical variance. Now, of course, if I write it like that for all u's in our d, what is the value of this maximum? It's infinity, right? Because I can always multiply u by 10, and this entire thing is going to be multiplied by 100. So I'm just going to take u as large as I want, and this thing is going to be as large as I want. And so I need to constrain u. And as I said, I need to have u of size 1 to talk about coordinates in the system generated by u like this. So I'm just going to constrain u to have norm, Euclidean norm, equal to 1. So that's going to be my goal, trying to find the largest possible u transpose Su, or in other words, empirical variance of the points projected onto the direction u when u is of norm 1, which justifies to use the word direction because there's no magnitude to this u. OK, so how am I going to do this? I could just fold and say, let's just optimize this thing. Let's just take this problem. It says maximize a function onto some constraints. Admittedly, the constraint is sort of nasty. I'm on a sphere, and I'm trying to move points on the sphere, and I'm maximizing this thing, which actually happens to be convex. And we know we know how to minimize convex functions, but maximize them is a different question. And so this problem might be super hard. So I can just say, OK, here's what I want to do, and let me give that to an optimizer and just hope that the optimizer can solve this problem for me. That's one thing we can do. Now, as you can imagine, PCA is so well spread. Principal component analysis is something that people do constantly. And so that means that we know how to do this fast. So that's one thing. The other thing that you should probably question about why, if this thing is actually difficult, why in the world would you even choose the variance as a measure of spread if there's so many measures of spread? The variance is one measure of spread. It's not guaranteed that everything is going to project nicely far apart from each other. So we could choose the variance, but we could choose something else. If the variance does not help, why choose it? It turns out the variance helps. So this is indeed a non-convex problem. I'm maximizing. So it's actually the same. I can make this constraint convex, because I'm maximizing a convex function. So it's clear that the maximum is going to be attained at the boundary. So I can actually just fill this ball into some convex ball. However, I'm still maximizing. So this is a non-convex problem. And this turns out to be the fanciest non-convex problem we know how to solve. And the reason why we know how to solve it is not because of optimization or using gradient type things or anything of the algorithms that I mentioned during the maximum likelihood. It's because of linear algebra. Linear algebra guarantees that we know how to solve this. And to understand this, we need to go a little deeper in linear algebra, and we need to understand the concept of diagonalization of a matrix. So who has ever seen the concept of an eigenvalue? Oh, that's beautiful. And if you're not raising your hand, you're just playing Candy Crush, right? All right. So OK, so this is great. Everybody's seen it. For my live audience of millions, maybe you have not. So I will still go through it. All right, so one of the basic facts, and I remember when I learned this in when I was an undergrad, I learned about the spectral decomposition and this diagonalization of matrices. And for me, it was just a structural property of matrices. But it turns out that it's extremely useful, and it's useful for algorithmic purposes. And so what this theorem tells you is that if you take a symmetric matrix with real entries, but that really does not matter so much. And here, I'm going to actually, so I take a symmetric matrix. And actually, S and sigma are two such symmetric matrices, right? Then there exists P and D, which are both, so let's say, D by D, which are both D by D, such that P is orthogonal. That means that P transpose P is equal to P P transpose is equal to the identity. And D is diagonal. And sigma, let's say, is equal to P D P transpose. So it's a diagonalization because it's finding a nice transformation. P has some nice properties. It's really just a change of coordinates in which your matrix is diagonal. And the way you want to see this, and I think it sort of helps to think about this problem as sigma being a covariance matrix. What does a covariance matrix tell you? Think of a multivariate Gaussian. Can everybody visualize a two-dimensional Gaussian density? So it's going to be some sort of bell-shaped curve, but it might be more elongated in one direction than another. And then I'm going to chop it like that. So I'm going to chop it off, and I'm going to look at how it bleeds. So I'm just going to look at where the blot is. And what it's going to look at is going to look like some sort of ellipsoid. In high dimension, it's just going to be an olive. And it's just going to be bigger and bigger. And I chop it off a little lower, and I get something a little bigger like this. And so it turns out that sigma is capturing exactly this. The matrix sigma, so the center of your covariance matrix of your Gaussian is going to be this thing. And sigma is going to tell you which direction it's elongated. And so in particular, if you know an ellipse, you know there's something called principal axis. So you can actually define something that looks like this, which is this axis, the one along which is the most elongated, then the axis along which is orthogonal to it, along which it's slightly less elongated. And you go again and again along the orthogonal ones. It turns out that those things here is the new coordinate system in which this transformation, p and p transpose, is putting you into. And d has entries on the diagonal, which are exactly this length and this length. So that's just what it's doing. It's just telling you, well, if you think of having this Gaussian or this high-dimensional ellipsoid, it's elongated along certain directions. And those directions are actually maybe not well-aligned with your original coordinate system, which might just be the usual one, right? North, south, and east, west. Maybe I need to turn it, and that's exactly what this orthogonal transformation is doing for you. So in a way, this is actually telling you even more. It's telling you that any matrix that's symmetric, you can actually turn it somewhere, now start to dilate things in the directions that you have, and then turn it back to what you originally had. And that's actually exactly the effect of applying a symmetric matrix to a vector. It's sort of pretty impressive. It says, if I take sigma times v, any sigma that's of this form, what I'm doing is that's symmetric. What I'm really doing to v is I'm changing its coordinate system, so I'm rotating it. Then I'm multiplying its coordinates, and then I'm rotating it back. That's all it's doing, and that's what all symmetric matrices do, which means that this is doing a lot. So what do I know? So I'm not going to prove that. This is the so-called spectral theorem. And the diagonal entries of D is of the form lambda 1, lambda 2, lambda d, 0, 0. And the lambda j's are called eigenvalues of D. Now, in general, those numbers can be positive, negative, or equal to 0. But here, I know that sigma and S are symmetric for sure, but they are positive semi-definite. What does it mean? It means that when I take u transpose sigma u, for example, this number is always non-negative. Why is this true? What is this number? It's the variance of, and actually, I don't even need to finish this sentence. As soon as I say that this is a variance, well, it has to be non-negative. We know that a variance is non-negative. And so that's also a nice way you can use that. It's just to say, well, OK, this thing is positive semi-definite because it's a covariance matrix. So I know it's a variance. So I get this. Now, if I had some negative numbers, so the effect of that is that when I draw this picture, those axes are always positive, which is kind of a weird thing to say. But what it means is that when I take a vector v, I rotate it, and then I stretch it in the directions of the coordinate, I cannot flip it. I can only stretch or shrink, but I cannot flip its sign. But in general, for any symmetric matrices, I could do this. But when it's positive symmetric definite, actually what turns out is that all the lambda j's are non-negative. I cannot flip it. So all the eigenvalues are non-negative. That's the property of positive semi-definite. So when it's symmetric, you have the eigenvalues. They can be any number. And when it's positive semi-definite, in particular, that's the case of the covariance matrix and the empirical covariance matrix, because the empirical covariance matrix is an empirical variance, which itself is non-negative. And so I get that the eigenvalues are non-negative. All right, so principal component analysis is saying, OK, I want to find the direction u that maximizes u transpose Su. I've just introduced in one slide something about eigenvalues. So hopefully, they should help. So what is it that I'm going to be getting? Well, let's just see what happens. Oh, I forgot to mention, and I will use this. So the lambda j's are called eigenvectors. And then the matrix P has columns v1 to vd. The fact that it's orthogonal, that P transpose P is equal to the identity, means that those guys satisfy that vi transpose vj is equal to 0 if i is different from j. And vi transpose vi is actually equal to 1, because the entries of P P transpose are exactly going to be of the form vi transpose vj. So those v's are called eigenvectors. And v1 is attached to lambda 1, and v2 is attached to lambda 2. So let's see what's happening with those things. What happens if I take sigma? So if you know eigenvalues, you know exactly what's going to happen. If I look at, say, sigma times v1, well, what is sigma? We know that sigma is Pd P transpose v1. What is P transpose times v1? Well, P transpose has rows v1 transpose, v2 transpose, all the way to vd transpose. So when I multiply this by v1, what I'm left with is the first coordinate is going to be equal to 1. And the second coordinate is going to be equal to 0, because they are orthogonal to each other. 0 all the way to the end. So that's when I do P transpose v1. Now I multiply by d. Well, I'm just multiplying this guy by lambda 1, this guy by lambda 2, and this guy by lambda d. So this is really just lambda 1. And now I need to post-multiply by P. So what is P times this guy? Well, P is v1 all the way to vd. And now I multiply by a vector that only has 0's, except lambda 1 on the first guy. So this is just lambda 1 times v1. So what we've proved is that sigma times v1 is lambda 1 v1. And that's probably the notion of eigenvalue you're most comfortable with. So just when I multiply by v1, I get v1 back, multiplied by something, which is the eigenvalue. So in particular, if I look at v1 transpose sigma v1, what do I get? Well, I get lambda 1 v1 transpose v1, which is 1. So this is actually lambda 1 v1 transpose v1, which is lambda 1. And if I do the same with v2, clearly I'm going to get v2 transpose sigma v2 is equal to lambda 2. So for each of the vj's, I know that if I look at the variance along the vj, it's actually exactly given by those eigenvalues, which proves this. Why? Because the variance along the eigenvectors is actually equal to the eigenvalues. So since they're variances, they have to be non-negative. So now I'm looking for the one direction that has the most variance. But that's not only among the eigenvectors. That's also among the other directions that are in between the eigenvectors. If I were to look only at the eigenvectors, it would just tell me, well, just pick the eigenvector vj that's associated to the largest of the lambda j's. Well, it turns out that that's also true for any vector, that the maximum direction is actually one direction which is among the eigenvectors. And among the eigenvectors, we know that the one that carries the largest variance is the one that's associated to the largest eigenvalue. And so this is what PCA is going to try to do for me. So in practice, that's what I mentioned already. We're trying to project a point cloud onto a low-dimensional space d prime by keeping as much information as possible. And by as much information, I mean we do not want points to collide. And so what PCA is going to do is just going to try to project on two directions. So there's going to be a u, and then there's going to be something orthogonal to u, and then a third one, et cetera. So that once we project on those, we're keeping as much of the covariance as possible. And in particular, those directions that we're going to pick are actually subsets of the vj's that are associated to the largest eigenvalues. So I'm going to stop here for today. We'll finish this on Tuesday. But basically, the idea is just the following. You're just going to, well, let me skip one more. Yeah, this is the idea. You're first going to pick the eigenvector associated to the largest eigenvalue. Then you're going to pick the direction that's orthogonal to the vector that you've picked and that's carrying the most variance. And that's actually the eigenvector associated to the second largest eigenvalue. And you're going to go all the way to the number of them that you actually want to pick, which is in this case d. And wherever you choose to chop this process, not going all the way to d, is going to actually give you a lower dimensional representation in the coordinate system that's given by v1, v2, v3, et cetera. So we'll see that in more details on Tuesday, but I don't want to get into it now. We don't have enough time. Are there any questions?